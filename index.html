<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SFDC SOQL ‚Üí CSV Validator (v2)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0f172a;--card:#111827;--muted:#1f2937;--text:#e5e7eb;--sub:#9ca3af;--ok:#10b981;--bad:#ef4444;--accent:#6366f1}
    *{box-sizing:border-box}body{margin:0;background:linear-gradient(180deg,#0b1022,#0f172a 25%);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--text)}
    .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
    h1{margin:0 0 10px;font-size:28px;font-weight:800;letter-spacing:.2px}
    .sub{color:var(--sub);font-size:14px;margin-bottom:22px}
    .card{background:rgba(17,24,39,.85);border:1px solid #222;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:16px;margin-bottom:14px}
    textarea{width:100%;min-height:110px;background:#0b1221;color:var(--text);border:1px solid #243047;border-radius:10px;padding:12px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;line-height:1.35}
    .row{display:grid;gap:12px}
    @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
    .btn{cursor:pointer;border:none;padding:12px 16px;border-radius:11px;background:var(--accent);color:white;font-weight:700}
    .btn.secondary{background:#374151}
    .btn.small{padding:6px 10px;border-radius:8px;font-weight:600}
    .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
    .kpi{background:#0c1326;border:1px solid #1f2a44;border-radius:12px;padding:12px}
    .kpi h3{margin:0;font-size:12px;color:#9aa7bd;text-transform:uppercase;letter-spacing:.8px}
    .kpi .v{font-size:22px;font-weight:800;margin-top:6px}
    .kpi.good{border-color:#134e4a}.kpi.bad{border-color:#4c1d1d}.kpi.rate{border-color:#1e3a8a}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:8px 0}
    .chip{border:1px solid #334155;color:#cbd5e1;padding:4px 10px;border-radius:999px;font-size:13px}
    .chip.good{border-color:#065f46;color:#34d399}
    .chip.bad{border-color:#7f1d1d;color:#fca5a5}
    .table{width:100%;border-collapse:separate;border-spacing:0 8px}
    .th{color:#9aa7bd;text-align:left;font-size:12px;text-transform:uppercase;letter-spacing:.7px}
    .rowtr{background:#0b1221;border:1px solid #1f2a44}
    .rowtr td{padding:10px 12px;vertical-align:top}
    .rowtr.valid{background:#0c1f16;border-color:#14532d}
    .rowtr.invalid{background:#271316;border-color:#7f1d1d}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;font-weight:700}
    .badge.ok{background:#14532d;color:#a7f3d0}
    .badge.no{background:#7f1d1d;color:#fecaca}
    .muted{color:#a3aed0}
    input[type="file"]{display:none}
    .filelabel{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border:1px dashed #334155;border-radius:10px;cursor:pointer;color:#cbd5e1}
    .split3{display:grid;gap:12px;grid-template-columns:1fr}
    @media(min-width:900px){.split3{grid-template-columns:2fr 1fr 1fr}}
    .note{font-size:12px;color:#94a3b8}
    .hl{color:#93c5fd}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>üîé SFDC SOQL ‚Üí CSV Validator (v2)</h1>
    <div class="sub">Frontend-only validator for <strong>SOQL WHERE</strong>. Host on GitHub Pages. <br/>Supported: <span class="hl">AND</span>, <span class="hl">OR</span>, <span class="hl">NOT</span>, parentheses, <span class="hl">= != &gt; &gt;= &lt; &lt;=</span>, <span class="hl">LIKE / NOT LIKE</span>, <span class="hl">IN / NOT IN</span>, <span class="hl">IS NULL / IS NOT NULL</span>, <span class="hl">BETWEEN</span>, <span class="hl">LOWER/UPPER</span>, <span class="hl">date literal: TODAY</span> (using browser local date).</div>

    <div class="card split3">
      <div>
        <label class="muted">SOQL Query</label>
        <textarea id="soql" placeholder="SELECT Id FROM Account WHERE (Status = 'Inactive' AND Name LIKE '%2') OR CreatedDate = TODAY"></textarea>
        <div class="toolbar">
          <button class="btn small secondary" id="loadExample">Load Example</button>
          <span class="note">Tip: <span class="hl">TODAY</span> resolves to your local date (00:00). For CSV dates use <code>YYYY-MM-DD</code> or <code>DD/MM/YYYY</code>.</span>
        </div>
      </div>
      <div>
        <label for="file" class="filelabel">üìÑ Upload CSV file</label>
        <input id="file" type="file" accept=".csv" />
        <div id="filename" class="note" style="margin-top:8px"></div>
      </div>
      <div>
        <label class="muted">Paste CSV Data</label>
        <textarea id="csv" placeholder="Name,Status,Amount,Type,CreatedDate\nAccount 1,Active,1000,Customer,2025-08-21\nAccount 2,Inactive,500,Prospect,2025-08-23\nAccount 3,Active,2000,Partner,23/08/2025"></textarea>
      </div>
    </div>

    <div class="card">
      <button class="btn" id="run">üìå Validate Query</button>
      <button class="btn secondary" id="download" style="margin-left:8px" disabled>‚¨áÔ∏è Download Results CSV</button>
      <div id="status" class="note" style="margin-top:10px"></div>
    </div>

    <div id="results"></div>
  </div>

<script>
// -------- Helpers --------
const likeToRegex = (pattern) => {
  let esc = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  esc = esc.replace(/%/g, '.*').replace(/_/g, '.');
  return new RegExp('^' + esc + '$', 'i');
};

const parseValue = (tok) => {
  if (tok === undefined) return null;
  const up = (s)=>String(s||'').toUpperCase();
  // SOQL date literals
  if (up(tok)==='TODAY') return {__SOQL_DATE_LITERAL:'TODAY'};
  if (up(tok)==='YESTERDAY') return {__SOQL_DATE_LITERAL:'YESTERDAY'};
  if (up(tok)==='TOMORROW') return {__SOQL_DATE_LITERAL:'TOMORROW'};
  const m = /^LAST_N_DAYS\s*:\s*(\d+)$/i.exec(tok);
  if (m) return {__SOQL_DATE_LITERAL:'LAST_N_DAYS', n: Number(m[1])};

  if ((tok.startsWith("'") && tok.endsWith("'")) || (tok.startsWith('"') && tok.endsWith('"'))){
    return tok.slice(1, -1);
  }
  if (/^(true|false)$/i.test(tok)) return /^true$/i.test(tok);
  if (!isNaN(Number(tok))) return Number(tok);
  return tok; // bare identifier
};

function tokenize(expr){
  const tokens=[]; let i=0; const s=expr.trim();
  const push=(t)=>tokens.push(t);
  while(i<s.length){
    const c=s[i];
    if(/\s/.test(c)){i++; continue;}
    if(c==='('||c===')'){push(c); i++; continue;}
    if(c==="'"||c==='"'){
      const q=c; let j=i+1; let str=q;
      while(j<s.length){ if(s[j]===q && s[j-1]!=="\\"){str+=q; j++; break;} str+=s[j++]; }
      push(str); i=j; continue;
    }
    const op2 = s.slice(i,i+2).toUpperCase();
    if(['>=','<=','!='].includes(op2)){push(op2); i+=2; continue;}
    if(['>','<','=','\n',','].includes(c)){push(c); i++; continue;}
    let j=i; while(j<s.length && /[\w.$:]/.test(s[j])) j++;
    push(s.slice(i,j)); i=j;
  }
  return tokens;
}

function extractWhere(soql){
  const m = /\bWHERE\b([\s\S]*)/i.exec(soql);
  if(!m) return '';
  let w = m[1];
  const cut = /\b(ORDER\s+BY|LIMIT|GROUP\s+BY|OFFSET)\b/i.exec(w);
  if(cut) w = w.slice(0, cut.index);
  return w.trim();
}

function parseWhere(where){
  const t = tokenize(where); let i=0; const up=(x)=>String(x||'').toUpperCase();
  const peek=()=>t[i]; const eat=(x)=>{ if(x && up(peek())!==x) throw new Error('Expected '+x+' near '+peek()); return t[i++]; };
  const eatIf=(x)=> up(peek())===x ? t[i++] : null; const eatAny=()=>t[i++];

  function parseExpression(){ let node=parseTerm(); while(peek() && up(peek())==='OR'){eat('OR'); node={type:'OR',left:node,right:parseTerm()};} return node; }
  function parseTerm(){ let node=parseFactor(); while(peek() && up(peek())==='AND'){eat('AND'); node={type:'AND',left:node,right:parseFactor()};} return node; }
  function parseFactor(){ if(peek()==='('){eat('('); const e=parseExpression(); eat(')'); return e;} if(up(peek())==='NOT'){eat('NOT'); return {type:'NOT',expr:parseFactor()};} return parseComparison(); }

  function parseFieldWithFunc(){
    let field=eatAny(); let fieldFunc=null; const u=up(field);
    if(['LOWER','UPPER'].includes(u)){ const func=u; eat('('); const inner=eatAny(); eat(')'); field=inner; fieldFunc=func; }
    return {funcOnly:false, field, fieldFunc};
  }

  function parseComparison(){
    const f=parseFieldWithFunc(); const field=f.field, fieldFunc=f.fieldFunc;
    if(up(peek())==='IS'){ eat('IS'); const not=!!eatIf('NOT'); eat('NULL'); return {type:not?'IS_NOT_NULL':'IS_NULL', field, fieldFunc}; }

    let opWord = up(eatAny()); let isNot=false; if(opWord==='NOT'){ isNot=true; opWord=up(eatAny()); }
    if(opWord==='IN'){ eat('('); const vals=[]; while(peek() && peek()!==')'){ const v=parseValue(eatAny()); vals.push(v); if(peek()===',') eat(','); } eat(')'); return {type:isNot?'NOT_IN':'IN', field, fieldFunc, vals}; }
    if(opWord==='LIKE'){ const pat=parseValue(eatAny()); return {type:isNot?'NOT_LIKE':'LIKE', field, fieldFunc, pat}; }
    if(opWord==='BETWEEN'){ const a=parseValue(eatAny()); eat('AND'); const b=parseValue(eatAny()); return {type:'BETWEEN', field, fieldFunc, a, b}; }

    const val=parseValue(eatAny()); return {type:'CMP', field, fieldFunc, op:opWord, val};
  }
  return parseExpression();
}

function getFieldValue(row, field){ const parts=String(field).split('.'); let v=row; for(const p of parts){ if(v==null) return undefined; v=v[p]; } return v; }

function toStringCond(c){ switch(c.type){
  case 'IN': return `${c.field} IN (${c.vals.map(v=>JSON.stringify(v)).join(', ')})`;
  case 'NOT_IN': return `${c.field} NOT IN (${c.vals.map(v=>JSON.stringify(v)).join(', ')})`;
  case 'LIKE': return `${c.field} LIKE ${JSON.stringify(c.pat)}`;
  case 'NOT_LIKE': return `${c.field} NOT LIKE ${JSON.stringify(c.pat)}`;
  case 'CMP': return `${c.field} ${c.op} ${JSON.stringify(c.val)}`;
  case 'BETWEEN': return `${c.field} BETWEEN ${JSON.stringify(c.a)} AND ${JSON.stringify(c.b)}`;
  case 'IS_NULL': return `${c.field} IS NULL`;
  case 'IS_NOT_NULL': return `${c.field} IS NOT NULL`;
  case 'AND': return `(${toStringCond(c.left)} AND ${toStringCond(c.right)})`;
  case 'OR': return `(${toStringCond(c.left)} OR ${toStringCond(c.right)})`;
  case 'NOT': return `(NOT ${toStringCond(c.expr)})`;
  default: return '';
}}

// Resolve SOQL date literal or date-like values
function resolveDateMeta(x){
  const toMid = (d)=> new Date(d.getFullYear(), d.getMonth(), d.getDate());
  const today = toMid(new Date());
  const makeRange=(start,end)=>({type:'range', start:toMid(start), end:toMid(end)});
  if(x && typeof x==='object' && x.__SOQL_DATE_LITERAL){
    switch(x.__SOQL_DATE_LITERAL){
      case 'TODAY': return {type:'date', value: today};
      case 'YESTERDAY': { const d=new Date(today); d.setDate(d.getDate()-1); return {type:'date', value:d}; }
      case 'TOMORROW': { const d=new Date(today); d.setDate(d.getDate()+1); return {type:'date', value:d}; }
      case 'LAST_N_DAYS': { const d1=new Date(today); d1.setDate(d1.getDate()-(x.n||0)); return makeRange(d1, today); }
    }
  }
  if(x==null) return null;
  const parseDateGuess=(s)=>{ if(s instanceof Date) return toMid(s); const str=String(s).trim();
    let m=str.match(/^(\d{4})-(\d{2})-(\d{2})$/); if(m) return new Date(+m[1],+m[2]-1,+m[3]);
    m=str.match(/^(\d{2})\/(\d{2})\/(\d{4})$/); if(m) return new Date(+m[3],+m[2]-1,+m[1]);
    const dt=new Date(str); if(!isNaN(dt)) return toMid(dt); return null; };
  const dt = parseDateGuess(x);
  return dt? {type:'date', value:dt} : null;
}

function evalAst(ast, row, reasons){
  if(!ast) return {ok:true};
  if(['AND','OR','NOT'].includes(ast.type)){
    if(ast.type==='NOT'){ const r=evalAst(ast.expr,row,reasons); return {ok:!r.ok, meta:ast}; }
    const l=evalAst(ast.left,row,reasons); const r=evalAst(ast.right,row,reasons);
    if(ast.type==='AND') return {ok:l.ok && r.ok, meta:[l.meta,r.meta]};
    return {ok:l.ok || r.ok, meta:[l.meta,r.meta]};
  }
  let val=getFieldValue(row, ast.field);
  if(ast.fieldFunc==='LOWER' && typeof val==='string') val=val.toLowerCase();
  if(ast.fieldFunc==='UPPER' && typeof val==='string') val=val.toUpperCase();

  let ok=false;
  switch(ast.type){
    case 'IN': ok = ast.vals.some(v=>String(v).toLowerCase()===String(val).toLowerCase()); break;
    case 'NOT_IN': ok = !ast.vals.some(v=>String(v).toLowerCase()===String(val).toLowerCase()); break;
    case 'LIKE': ok = likeToRegex(typeof ast.pat==='string'? ast.pat : String(ast.pat)).test(String(val??'')); break;
    case 'NOT_LIKE': ok = !likeToRegex(typeof ast.pat==='string'? ast.pat : String(ast.pat)).test(String(val??'')); break;
    case 'BETWEEN': {
      const A = resolveDateMeta(ast.a); const B = resolveDateMeta(ast.b); const V = resolveDateMeta(val);
      if(A && B && V && A.type==='date' && B.type==='date' && V.type==='date'){
        ok = (V.value >= A.value && V.value <= B.value);
      } else {
        ok = Number(val) >= Number(ast.a) && Number(val) <= Number(ast.b);
      }
    } break;
    case 'IS_NULL': ok = (val===null || val===undefined || val===''); break;
    case 'IS_NOT_NULL': ok = !(val===null || val===undefined || val===''); break;
    case 'CMP':{
      const L = resolveDateMeta(val); const R = resolveDateMeta(ast.val);
      if(L && (R && (R.type==='date' || R.type==='range'))){
        const a = L.type==='date' ? L.value.getTime() : NaN;
        const cmp = (num, op, ref)=>{ switch(op){ case '=': return num===ref; case '!=': return num!==ref; case '>': return num>ref; case '>=': return num>=ref; case '<': return num<ref; case '<=': return num<=ref; default: return false; } };
        if(R.type==='date'){
          ok = cmp(a, ast.op, R.value.getTime());
        } else { // range LAST_N_DAYS
          const start=R.start.getTime(), end=R.end.getTime();
          switch(ast.op){
            case '=': ok = (a>=start && a<=end); break;
            case '!=': ok = !(a>=start && a<=end); break;
            case '>': ok = a> end; break;
            case '>=': ok = a>= start; break;
            case '<': ok = a< start; break;
            case '<=': ok = a<= end; break;
            default: ok=false;
          }
        }
        break;
      }
      const a = val, b = ast.val;
      switch(ast.op){
        case '=': ok = String(a)==String(b); break;
        case '!=': ok = String(a)!=String(b); break;
        case '>': ok = Number(a)>Number(b); break;
        case '>=': ok = Number(a)>=Number(b); break;
        case '<': ok = Number(a)<Number(b); break;
        case '<=': ok = Number(a)<=Number(b); break;
        default: ok=false;
      }
    } break;
  }
  if(ok) reasons.push(toStringCond(ast));
  return {ok, meta:ast};
}

function unparseCSV(rows){ return Papa.unparse(rows); }

// -------- App --------
const soqlEl=document.getElementById('soql');
const csvEl=document.getElementById('csv');
const fileEl=document.getElementById('file');
const fileNameEl=document.getElementById('filename');
const statusEl=document.getElementById('status');
const resultsEl=document.getElementById('results');
const runBtn=document.getElementById('run');
const dlBtn=document.getElementById('download');

const exampleSOQL = "SELECT Id, Name FROM Account WHERE (Status = 'Inactive' AND Name LIKE '%2') OR CreatedDate = TODAY OR LastModifiedDate = YESTERDAY OR CloseDate = LAST_N_DAYS:30";
const exampleCSV = `Name,Status,Amount,Type,CreatedDate,LastModifiedDate,CloseDate
Account 1,Active,1000,Customer,2025-08-21,2025-08-22,2025-07-30
Account 2,Inactive,500,Prospect,2025-08-23,2025-08-22,2025-08-10
Account 3,Active,2000,Partner,23/08/2025,22/08/2025,2025-06-01`;

document.getElementById('loadExample').onclick=()=>{ soqlEl.value=exampleSOQL; csvEl.value=exampleCSV; };

fileEl.addEventListener('change',(e)=>{ const f=e.target.files?.[0]; if(!f) return; fileNameEl.textContent=f.name; Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{ csvEl.value=unparseCSV(res.data); }}); });

runBtn.onclick = () => {
  try{
    const where = extractWhere(soqlEl.value || '');
    if(!where){ alert('No WHERE clause found. We will treat it as TRUE for all rows.'); }
    const ast = parseWhere(where || '');

    const data = Papa.parse(csvEl.value || '', {header:true, skipEmptyLines:true});
    if(data.errors?.length){ throw new Error('CSV parse error: '+data.errors[0].message); }

    const rows = data.data; const out=[]; let valid=0, invalid=0;
    rows.forEach((row)=>{ const reasons=[]; const ok=!ast?true:evalAst(ast,row,reasons).ok; if(ok) valid++; else invalid++; out.push({...row, VALID: ok? 'TRUE':'FALSE', Explanation: ok? ('All conditions met: '+reasons.join('; ')) : ''}); });

    const total=rows.length||0; const rate=total? Math.round(valid*100/total):0;
    resultsEl.innerHTML = `
      <div class="card">
        <div class="kpis">
          <div class="kpi"><h3>Total</h3><div class="v">${total}</div></div>
          <div class="kpi good"><h3>Valid</h3><div class="v">${valid}</div></div>
          <div class="kpi bad"><h3>Invalid</h3><div class="v">${invalid}</div></div>
          <div class="kpi rate"><h3>Success Rate</h3><div class="v">${rate}%</div></div>
        </div>
        <div class="toolbar" style="margin-top:12px">
          <input id="search" placeholder="Search in results‚Ä¶" style="flex:1;min-width:200px;padding:8px 10px;border-radius:10px;border:1px solid #334155;background:#0b1221;color:#e5e7eb" />
          <span class="chip" id="fltAll">All</span>
          <span class="chip good" id="fltGood">Valid</span>
          <span class="chip bad" id="fltBad">Invalid</span>
        </div>
        <div style="overflow:auto;margin-top:6px">
          <table class="table" id="table">
            <thead>
              <tr>
                <th class="th">#</th>
                <th class="th">Data</th>
                <th class="th">Status</th>
                <th class="th">Explanation</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>`;

    const tbody=document.querySelector('#table tbody');
    const headers=data.meta.fields || Object.keys(rows[0]||{});

    function renderTable(filter='all', q=''){
      tbody.innerHTML='';
      out.forEach((r,i)=>{
        const ok = r.VALID==='TRUE';
        if(filter==='good' && !ok) return; if(filter==='bad' && ok) return;
        const textData = headers.map(h=>`${h}: ${r[h]??''}`).join('\n');
        const str = (textData + ' ' + (r.Explanation||'')).toLowerCase(); if(q && !str.includes(q.toLowerCase())) return;
        const tr = document.createElement('tr'); tr.className='rowtr ' + (ok? 'valid':'invalid');
        tr.innerHTML = `
          <td>${i+1}</td>
          <td><pre style="margin:0;white-space:pre-wrap">${textData}</pre></td>
          <td>${ok? '<span class="badge ok">Valid</span>' : '<span class="badge no">Invalid</span>'}</td>
          <td><pre style="margin:0;white-space:pre-wrap">${r.Explanation||''}</pre></td>`;
        tbody.appendChild(tr);
      });
    }

    renderTable();
    document.getElementById('fltAll').onclick=()=>renderTable('all', document.getElementById('search').value);
    document.getElementById('fltGood').onclick=()=>renderTable('good', document.getElementById('search').value);
    document.getElementById('fltBad').onclick=()=>renderTable('bad', document.getElementById('search').value);
    document.getElementById('search').oninput=(e)=>renderTable('all', e.target.value);

    dlBtn.disabled=false;
    dlBtn.onclick=()=>{ const csvOut=Papa.unparse(out); const blob=new Blob([csvOut],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='validation_results.csv'; a.click(); URL.revokeObjectURL(url); };

    statusEl.textContent = 'Validation completed: '+valid+' valid, '+invalid+' invalid.';
  }catch(err){ statusEl.textContent='Error: '+err.message; }
};
</script>


</body>
</html>
