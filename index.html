<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SFDC SOQL ‚Üí CSV Validator (v4)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0f172a;--card:#111827;--muted:#1f2937;--text:#e5e7eb;--sub:#9ca3af;--ok:#10b981;--bad:#ef4444;--accent:#6366f1}
    *{box-sizing:border-box}body{margin:0;background:linear-gradient(180deg,#0b1022,#0f172a 25%);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--text)}
    .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
    h1{margin:0 0 10px;font-size:28px;font-weight:800;letter-spacing:.2px}
    .sub{color:var(--sub);font-size:14px;margin-bottom:22px}
    .card{background:rgba(17,24,39,.85);border:1px solid #222;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:16px;margin-bottom:14px}
    textarea{width:100%;min-height:120px;background:#0b1221;color:var(--text);border:1px solid #243047;border-radius:10px;padding:12px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;line-height:1.35}
    .row{display:grid;gap:12px}
    @media(min-width:900px){.row{grid-template-columns:1fr 1fr}}
    .btn{cursor:pointer;border:none;padding:12px 16px;border-radius:11px;background:var(--accent);color:white;font-weight:700}
    .btn.secondary{background:#374151}
    .btn.small{padding:6px 10px;border-radius:8px;font-weight:600}
    .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
    .kpi{background:#0c1326;border:1px solid #1f2a44;border-radius:12px;padding:12px}
    .kpi h3{margin:0;font-size:12px;color:#9aa7bd;text-transform:uppercase;letter-spacing:.8px}
    .kpi .v{font-size:22px;font-weight:800;margin-top:6px}
    .kpi.good{border-color:#134e4a}.kpi.bad{border-color:#4c1d1d}.kpi.rate{border-color:#1e3a8a}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:8px 0}
    .chip{border:1px solid #334155;color:#cbd5e1;padding:4px 10px;border-radius:999px;font-size:13px}
    .chip.good{border-color:#065f46;color:#34d399}
    .chip.bad{border-color:#7f1d1d;color:#fca5a5}
    .table{width:100%;border-collapse:separate;border-spacing:0 8px}
    .th{color:#9aa7bd;text-align:left;font-size:12px;text-transform:uppercase;letter-spacing:.7px}
    .rowtr{background:#0b1221;border:1px solid #1f2a44}
    .rowtr td{padding:10px 12px;vertical-align:top}
    .rowtr.valid{background:#0c1f16;border-color:#14532d}
    .rowtr.invalid{background:#271316;border-color:#7f1d1d}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;font-weight:700}
    .badge.ok{background:#14532d;color:#a7f3d0}
    .badge.no{background:#7f1d1d;color:#fecaca}
    .muted{color:#a3aed0}
    input[type="file"]{display:none}
    .filelabel{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border:1px dashed #334155;border-radius:10px;cursor:pointer;color:#cbd5e1}
    .split3{display:grid;gap:12px;grid-template-columns:1fr}
    @media(min-width:900px){.split3{grid-template-columns:2fr 1fr 1fr}}
    .note{font-size:12px;color:#94a3b8}
    .hl{color:#93c5fd}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>üîé SFDC SOQL ‚Üí CSV Validator (v4)</h1>
    <div class="sub">Validate a <strong>SOQL WHERE</strong> against CSV rows entirely in your browser. Host on GitHub Pages. <br/>Supports: <span class="hl">AND</span>, <span class="hl">OR</span>, <span class="hl">NOT</span>, parentheses, <span class="hl">= != &gt; &gt;= &lt; &lt;= &lt;&gt;</span>, <span class="hl">LIKE / NOT LIKE</span>, <span class="hl">IN / NOT IN</span>, <span class="hl">IS NULL / IS NOT NULL</span>, <span class="hl">BETWEEN</span>, <span class="hl">LOWER/UPPER</span>, <span class="hl">date literals: TODAY, YESTERDAY, TOMORROW, LAST_N_DAYS:n</span>.</div>

    <div class="card split3">
      <div>
        <label class="muted">SOQL Query</label>
        <textarea id="soql" placeholder="SELECT Id FROM CampaignMember WHERE LastModifiedDate &gt;= LAST_N_DAYS:20 AND MQL_Status__c IS NULL AND NOT Email LIKE '%zoominfo%' "></textarea>
        <div class="toolbar">
          <button class="btn small secondary" id="loadExample">Load Example</button>
          <span class="note">Dotted fields supported (e.g. <span class=hl>Campaign.Name</span>, <span class=hl>Custom__r.Field__c</span>). CSV headers must match.</span>
        </div>
      </div>
      <div>
        <label for="file" class="filelabel">üìÑ Upload CSV file</label>
        <input id="file" type="file" accept=".csv" />
        <div id="filename" class="note" style="margin-top:8px"></div>
      </div>
      <div>
        <label class="muted">Paste CSV Data</label>
        <textarea id="csv" placeholder="Campaign.Name,Email,LastModifiedDate,CreatedDate,Type\nCWS_March25_Homepage_Hero_FC,garry@krosland.com,2025-08-22T16:19:02.000+0000,2025-08-04T13:13:27.000+0000,CWS"></textarea>
      </div>
    </div>

    <div class="card">
      <button class="btn" id="run">üìå Validate Query</button>
      <button class="btn secondary" id="download" style="margin-left:8px" disabled>‚¨áÔ∏è Download Results CSV</button>
      <div id="status" class="note" style="margin-top:10px"></div>
    </div>

    <div id="results"></div>
  </div>

<script>
// ---------- Utilities ----------
const likeToRegex = (pattern) => {
  let esc = String(pattern).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  esc = esc.replace(/%/g, '.*').replace(/_/g, '.');
  return new RegExp('^' + esc + '$', 'i');
};

const parseValue = (tok) => {
  if (tok === undefined) return null;
  const up = (s)=>String(s||'').toUpperCase();
  // SOQL date literals
  if (up(tok)==='TODAY') return {__SOQL_DATE_LITERAL:'TODAY'};
  if (up(tok)==='YESTERDAY') return {__SOQL_DATE_LITERAL:'YESTERDAY'};
  if (up(tok)==='TOMORROW') return {__SOQL_DATE_LITERAL:'TOMORROW'};
  const m = /^LAST_N_DAYS\s*:\s*(\d+)$/i.exec(tok);
  if (m) return {__SOQL_DATE_LITERAL:'LAST_N_DAYS', n: Number(m[1])};

  if ((tok.startsWith("'") && tok.endsWith("'")) || (tok.startsWith('"') && tok.endsWith('"'))){
    return tok.slice(1, -1);
  }
  if (/^(true|false)$/i.test(tok)) return /^true$/i.test(tok);
  if (!isNaN(Number(tok))) return Number(tok);
  return tok; // bare identifier
};

// Tokenizer for WHERE clause
function tokenize(expr){
  const tokens=[]; let i=0; const s=expr.trim();
  const push=(t)=>tokens.push(t);
  while(i<s.length){
    const c=s[i];
    if(/\s/.test(c)){i++; continue;}
    if(c==='('||c===')'){push(c); i++; continue;}
    if(c==='\''||c==='"'){
      const q=c; let j=i+1; let str=q;
      while(j<s.length){ if(s[j]===q && s[j-1]!=="\\"){str+=q; j++; break;} str+=s[j++]; }
      push(str); i=j; continue;
    }
    // 2-char ops including <>
    const two = s.slice(i,i+2);
    const twoUp = two.toUpperCase();
    if(['>=','<=','!=','<>'].includes(twoUp)){ push(twoUp); i+=2; continue; }
    // 1-char ops
    if(['>','<','=','\n',','].includes(c)){push(c); i++; continue;}
    // identifiers: allow -, :, . inside tokens (ISO dates, LAST_N_DAYS:n, dotted fields)
    let j=i; while(j<s.length && /[\w.$:\-]/.test(s[j])) j++;
    push(s.slice(i,j)); i=j;
  }
  return tokens;
}

function extractWhere(soql){
  const m = /\bWHERE\b([\s\S]*)/i.exec(soql);
  if(!m) return '';
  let w = m[1];
  const cut = /\b(ORDER\s+BY|LIMIT|GROUP\s+BY|OFFSET)\b/i.exec(w);
  if(cut) w = w.slice(0, cut.index);
  return w.trim();
}

// Parser
function parseWhere(where){
  const t = tokenize(where); let i=0; const up=(x)=>String(x||'').toUpperCase();
  const peek=()=>t[i]; const eat=(x)=>{ if(x && up(peek())!==x) throw new Error('Expected '+x+' near '+peek()); return t[i++]; };
  const eatIf=(x)=> up(peek())===x ? t[i++] : null; const eatAny=()=>t[i++];

  function parseExpression(){ let node=parseTerm(); while(peek() && up(peek())==='OR'){eat('OR'); node={type:'OR', left:node, right:parseTerm()}; } return node; }
  function parseTerm(){ let node=parseFactor(); while(peek() && up(peek())==='AND'){eat('AND'); node={type:'AND', left:node, right:parseFactor()}; } return node; }
  function parseFactor(){ if(peek()==='('){eat('('); const e=parseExpression(); eat(')'); return e;} if(up(peek())==='NOT'){eat('NOT'); return {type:'NOT', expr:parseFactor()};} return parseComparison(); }

  function parseFieldWithFunc(){
    let field=eatAny(); let fieldFunc=null; const u=up(field);
    if(['LOWER','UPPER'].includes(u)){ const func=u; eat('('); const inner=eatAny(); eat(')'); field=inner; fieldFunc=func; }
    return {field, fieldFunc};
  }

  function parseComparison(){
    const f=parseFieldWithFunc(); const field=f.field, fieldFunc=f.fieldFunc;
    if(up(peek())==='IS'){ eat('IS'); const not=!!eatIf('NOT'); eat('NULL'); return {type:not?'IS_NOT_NULL':'IS_NULL', field, fieldFunc}; }

    // support NOT X (for NOT IN / NOT LIKE)
    let opWord; let isNot=false;
    const nextTok = up(peek());
    if(nextTok==='NOT'){ eat('NOT'); isNot=true; opWord = up(eatAny()); }
    else {
      // support <>
      const cur = up(peek());
      if(cur==='<>'){ eat('<>'); opWord='!='; }
      else opWord = up(eatAny());
    }

    if(opWord==='IN'){
      eat('('); const vals=[]; while(peek() && peek()!==')'){ const v=parseValue(eatAny()); vals.push(v); if(peek()===',') eat(','); } eat(')');
      return {type: isNot? 'NOT_IN':'IN', field, fieldFunc, vals};
    }
    if(opWord==='LIKE'){
      const pat = parseValue(eatAny());
      return {type: isNot? 'NOT_LIKE':'LIKE', field, fieldFunc, pat};
    }
    if(opWord==='BETWEEN'){
      const a=parseValue(eatAny()); eat('AND'); const b=parseValue(eatAny());
      return {type:'BETWEEN', field, fieldFunc, a, b};
    }

    const val=parseValue(eatAny());
    return {type:'CMP', field, fieldFunc, op:opWord, val};
  }
  return parseExpression();
}

// Value access supporting dotted headers or flat dotted keys
function getFieldValue(row, field){
  // prefer exact header match first
  if(Object.prototype.hasOwnProperty.call(row, field)) return row[field];
  // otherwise try dotted path into nested object (if provided as nested JSON)
  const parts = String(field).split('.'); let v = row;
  for(const p of parts){ if(v==null) return undefined; v = v[p]; }
  return v;
}

function toStringCond(c){ switch(c.type){
  case 'IN': return `${c.field} IN (${c.vals.map(v=>JSON.stringify(v)).join(', ')})`;
  case 'NOT_IN': return `${c.field} NOT IN (${c.vals.map(v=>JSON.stringify(v)).join(', ')})`;
  case 'LIKE': return `${c.field} LIKE ${JSON.stringify(c.pat)}`;
  case 'NOT_LIKE': return `${c.field} NOT LIKE ${JSON.stringify(c.pat)}`;
  case 'CMP': return `${c.field} ${c.op} ${JSON.stringify(c.val)}`;
  case 'BETWEEN': return `${c.field} BETWEEN ${JSON.stringify(c.a)} AND ${JSON.stringify(c.b)}`;
  case 'IS_NULL': return `${c.field} IS NULL`;
  case 'IS_NOT_NULL': return `${c.field} IS NOT NULL`;
  case 'AND': return `(${toStringCond(c.left)} AND ${toStringCond(c.right)})`;
  case 'OR': return `(${toStringCond(c.left)} OR ${toStringCond(c.right)})`;
  case 'NOT': return `(NOT ${toStringCond(c.expr)})`;
  default: return '';
}}

// ---- Date resolution ----
function resolveDateMeta(x){
  const toMid = (d)=> new Date(d.getFullYear(), d.getMonth(), d.getDate());
  const today = toMid(new Date());
  const makeRange=(start,end)=>({type:'range', start:toMid(start), end:toMid(end)});
  if(x && typeof x==='object' && x.__SOQL_DATE_LITERAL){
    switch(x.__SOQL_DATE_LITERAL){
      case 'TODAY': return {type:'date', value: today};
      case 'YESTERDAY': { const d=new Date(today); d.setDate(d.getDate()-1); return {type:'date', value:d}; }
      case 'TOMORROW': { const d=new Date(today); d.setDate(d.getDate()+1); return {type:'date', value:d}; }
      case 'LAST_N_DAYS': { const d1=new Date(today); d1.setDate(d1.getDate()-(x.n||0)); return {type:'range', start:d1, end:today}; }
    }
  }
  if(x==null) return null;
  const parseDateGuess=(s)=>{ if(s instanceof Date) return toMid(s); const str=String(s).trim();
    let m=str.match(/^(\d{4})-(\d{2})-(\d{2})$/); if(m) return new Date(+m[1],+m[2]-1,+m[3]);
    m=str.match(/^(\d{2})\/(\d{2})\/(\d{4})$/); if(m) return new Date(+m[3],+m[2]-1,+m[1]);
    // try full datetime
    const dt=new Date(str); if(!isNaN(dt)) return toMid(dt); return null; };
  const dt = parseDateGuess(x);
  return dt? {type:'date', value:dt} : null;
}

function evalAst(ast, row, reasons){
  if(!ast) return {ok:true};
  if(['AND','OR','NOT'].includes(ast.type)){
    if(ast.type==='NOT'){ const r=evalAst(ast.expr,row,reasons); return {ok:!r.ok, meta:ast}; }
    const l=evalAst(ast.left,row,reasons); const r=evalAst(ast.right,row,reasons);
    if(ast.type==='AND') return {ok:l.ok && r.ok, meta:[l.meta,r.meta]};
    return {ok:l.ok || r.ok, meta:[l.meta,r.meta]};
  }
  let val=getFieldValue(row, ast.field);
  if(ast.fieldFunc==='LOWER' && typeof val==='string') val=val.toLowerCase();
  if(ast.fieldFunc==='UPPER' && typeof val==='string') val=val.toUpperCase();

  let ok=false;
  switch(ast.type){
    case 'IN': ok = ast.vals.some(v=>String(v).toLowerCase()===String(val).toLowerCase()); break;
    case 'NOT_IN': ok = !ast.vals.some(v=>String(v).toLowerCase()===String(val).toLowerCase()); break;
    case 'LIKE': ok = likeToRegex(typeof ast.pat==='string'? ast.pat : String(ast.pat)).test(String(val??'')); break;
    case 'NOT_LIKE': ok = !likeToRegex(typeof ast.pat==='string'? ast.pat : String(ast.pat)).test(String(val??'')); break;
    case 'BETWEEN': {
      const dv=resolveDateMeta(val), da=resolveDateMeta(ast.a), db=resolveDateMeta(ast.b);
      if(dv && da && db && dv.type==='date' && da.type==='date' && db.type==='date'){
        ok = dv.value>=da.value && dv.value<=db.value;
      } else {
        ok = Number(val) >= Number(ast.a) && Number(val) <= Number(ast.b);
      }
    } break;
    case 'IS_NULL': ok = (val===null || val===undefined || val===''); break;
    case 'IS_NOT_NULL': ok = !(val===null || val===undefined || val===''); break;
    case 'CMP':{
      const L=resolveDateMeta(val); const R=resolveDateMeta(ast.val);
      if(L && (R && (R.type==='date' || R.type==='range'))){
        const a = L.type==='date' ? L.value.getTime() : NaN;
        if(R.type==='date'){
          const b=R.value.getTime();
          switch(ast.op){ case '=': ok=a===b; break; case '!=': ok=a!==b; break; case '>': ok=a>b; break; case '>=': ok=a>=b; break; case '<': ok=a<b; break; case '<=': ok=a<=b; break; default: ok=false; }
        } else { // LAST_N_DAYS range
          const start=R.start.getTime(), end=R.end.getTime();
          switch(ast.op){
            case '=': ok = (a>=start && a<=end); break;
            case '!=': ok = !(a>=start && a<=end); break;
            case '>': ok = a> end; break;
            case '>=': ok = a>= start; break;
            case '<': ok = a< start; break;
            case '<=': ok = a<= end; break;
            default: ok=false;
          }
        }
      } else {
        const a = val, b = ast.val;
        switch(ast.op){
          case '=': ok = String(a)==String(b); break;
          case '!=': ok = String(a)!=String(b); break;
          case '>': ok = Number(a)>Number(b); break;
          case '>=': ok = Number(a)>=Number(b); break;
          case '<': ok = Number(a)<Number(b); break;
          case '<=': ok = Number(a)<=Number(b); break;
          default: ok=false;
        }
      }
    } break;
  }
  if(ok) reasons.push(toStringCond(ast));
  return {ok, meta:ast};
}

function unparseCSV(rows){ return Papa.unparse(rows); }

// ---------- App Logic ----------
const soqlEl = document.getElementById('soql');
const csvEl = document.getElementById('csv');
const fileEl = document.getElementById('file');
const fileNameEl = document.getElementById('filename');
const statusEl = document.getElementById('status');
const resultsEl = document.getElementById('results');
const runBtn = document.getElementById('run');
const dlBtn = document.getElementById('download');

const exampleSOQL = "SELECT Id, Name FROM CampaignMember WHERE LastModifiedDate >= LAST_N_DAYS:20 AND Routing_process_result__c LIKE 'hot%' AND MQL_Status__c IS NULL AND NOT Email LIKE '%zoominfo%'";
const exampleCSV = `Campaign.Name,Email,LastModifiedDate,CreatedDate,Type\nCWS_March25_Homepage_Hero_FC,garry@krosland.com,2025-08-22T16:19:02.000+0000,2025-08-04T13:13:27.000+0000,CWS`;

document.getElementById('loadExample').onclick = ()=>{ soqlEl.value = exampleSOQL; csvEl.value = exampleCSV; };

fileEl.addEventListener('change', (e)=>{
  const f = e.target.files?.[0]; if(!f) return; fileNameEl.textContent = f.name;
  Papa.parse(f, {header:true, skipEmptyLines:true, complete: (res)=>{ csvEl.value = Papa.unparse(res.data); }});
});

runBtn.onclick = () => {
  try{
    const where = extractWhere(soqlEl.value || '');
    if(!where){ alert('No WHERE clause found. We will treat it as TRUE for all rows.'); }
    const ast = parseWhere(where || '');

    // Parse CSV with cleaning to avoid "Invalid array length" issues due to empty headers
    const parsed = Papa.parse(csvEl.value || '', {header:true, skipEmptyLines:true});
    if(parsed.errors?.length){ throw new Error('CSV parse error: '+parsed.errors[0].message); }

    const cleanRows = parsed.data.map((row) => {
      const out = {};
      for (const k in row) {
        if (k === '' || k == null) continue;        // drop empty header
        const key = String(k).trim();
        let val = row[k];
        if (typeof val === 'string') val = val.trim();
        out[key] = val;
      }
      return out;
    });

    const rows = cleanRows;
    const out = [];
    let valid=0, invalid=0;

    rows.forEach((row)=>{
      const reasons=[]; const ok = !ast ? true : evalAst(ast, row, reasons).ok;
      if(ok) valid++; else invalid++;
      out.push({...row, VALID: ok? 'TRUE':'FALSE', Explanation: ok? ('All conditions met: '+reasons.join('; ')) : ''});
    });

    // Render
    const total = rows.length || 0; const rate = total? Math.round(valid*100/total):0;
    resultsEl.innerHTML = `
      <div class="card">
        <div class="kpis">
          <div class="kpi"><h3>Total</h3><div class="v">${total}</div></div>
          <div class="kpi good"><h3>Valid</h3><div class="v">${valid}</div></div>
          <div class="kpi bad"><h3>Invalid</h3><div class="v">${invalid}</div></div>
          <div class="kpi rate"><h3>Success Rate</h3><div class="v">${rate}%</div></div>
        </div>
        <div class="toolbar" style="margin-top:12px">
          <input id="search" placeholder="Search in results‚Ä¶" style="flex:1;min-width:200px;padding:8px 10px;border-radius:10px;border:1px solid #334155;background:#0b1221;color:#e5e7eb" />
          <span class="chip" id="fltAll">All</span>
          <span class="chip good" id="fltGood">Valid</span>
          <span class="chip bad" id="fltBad">Invalid</span>
        </div>
        <div style="overflow:auto;margin-top:6px">
          <table class="table" id="table">
            <thead>
              <tr>
                <th class="th">#</th>
                <th class="th">Data</th>
                <th class="th">Status</th>
                <th class="th">Explanation</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>`;

    const tbody = document.querySelector('#table tbody');
    const headers = parsed.meta.fields?.filter(h=>h && h.trim()!=='') || Object.keys(rows[0]||{});

    function renderTable(filter='all', q=''){
      tbody.innerHTML='';
      out.forEach((r, i)=>{
        const ok = r.VALID==='TRUE';
        if(filter==='good' && !ok) return;
        if(filter==='bad' && ok) return;
        const textData = headers.map(h=>`${h}: ${r[h]??''}`).join('\n');
        const str = (textData + ' ' + (r.Explanation||'')).toLowerCase();
        if(q && !str.includes(q.toLowerCase())) return;
        const tr = document.createElement('tr');
        tr.className = 'rowtr ' + (ok? 'valid' : 'invalid');
        tr.innerHTML = `
          <td>${i+1}</td>
          <td><pre style="margin:0;white-space:pre-wrap">${textData}</pre></td>
          <td>${ok? '<span class="badge ok">Valid</span>' : '<span class="badge no">Invalid</span>'}</td>
          <td><pre style="margin:0;white-space:pre-wrap">${r.Explanation||''}</pre></td>`;
        tbody.appendChild(tr);
      });
    }

    renderTable();

    document.getElementById('fltAll').onclick = ()=>renderTable('all', document.getElementById('search').value);
    document.getElementById('fltGood').onclick = ()=>renderTable('good', document.getElementById('search').value);
    document.getElementById('fltBad').onclick = ()=>renderTable('bad', document.getElementById('search').value);
    document.getElementById('search').oninput = (e)=>renderTable('all', e.target.value);

    // enable download
    dlBtn.disabled = false;
    dlBtn.onclick = ()=>{
      const csvOut = Papa.unparse(out);
      const blob = new Blob([csvOut], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'validation_results.csv'; a.click();
      URL.revokeObjectURL(url);
    };

    statusEl.textContent = 'Validation completed: '+valid+' valid, '+invalid+' invalid.';
  }catch(err){
    console.error(err);
    statusEl.textContent = 'Error: '+err.message;
  }
};
</script>
</body>
</html>
